<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>

    <style>
        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 2px;
        }

        .grid line {
            stroke: lightgrey;
            stroke-opacity: 0.7;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        .tooltip {
            position: absolute;
            text-align: center;
            width: 60px;
            height: 28px;
            padding: 2px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <!-- Create a div where the circle will take place -->
    <div id="ftrent"></div>

    <div>
        <label>
            Saleable Area:
            <span id="xMin"></span> sqft
            <input type="range" name="xMaxSlider" id="xMaxSlider">
            <span id="xMax"></span> sqft
        </label>
    </div>

    <div>
        <label>
            Rent:
            $ <span id="yMin"></span>
            <input type="range" name="yMaxSlider" id="yMaxSlider">
            $ <span id="yMax"></span>
        </label>
    </div>

    <script>
        d3.csv('/24_tokwawan_cleaned.csv', function (data) {
            // set the dimensions and margins of the graph
            var margin = { top: 10, right: 30, bottom: 30, left: 60 },
                width = 980 - margin.left - margin.right,
                height = 980 * 9 / 16 - margin.top - margin.bottom;

            // append the SVG object to the body of the page
            var SVG = d3.select("#ftrent")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            const getX = d => parseInt(d.saleable_area);
            const getY = d => parseInt(d.rent);
            const xMin = 0;
            const xMax = d3.max(data, getX) * 1.1;
            const yMin = 0;
            const yMax = d3.max(data, getY) * 1.1;
            const xLabel = 'Saleable Area';
            const yLabel = 'Rent';

            // Add X axis
            var x = d3.scaleLinear()
                .domain([xMin, xMax])
                .range([0, width]);
            var xAxis = SVG.append("g")
                .attr("class", "grid")
                .attr("transform", "translate(0," + height + ")")
                .call(
                    d3.axisBottom(x)
                        .ticks(5)
                        .tickSize(-height)
                    // .tickFormat("")
                );

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([yMin, yMax])
                .range([height, 0]);
            var yAxis = SVG.append("g")
                .attr("class", "grid")
                .call(
                    d3.axisLeft(y)
                        .ticks(5)
                        .tickSize(-width)
                    // .tickFormat("")
                );

            // text label for the X axis
            SVG.append("text")
                .attr("transform",
                    "translate(" + (width / 2) + " ," +
                    (height + margin.top + 20) + ")")
                .style("text-anchor", "middle")
                .text(xLabel);

            // text label for the Y axis
            SVG.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (height / 2))
                .attr("dy", "1em")
                .style("text-anchor", "middle")
                .text(yLabel);

            // Add a clipPath: everything out of this area won't be drawn.
            var clip = SVG.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create the scatter variable: where both the circles and the brush take place
            var scatter = SVG.append('g')
                .attr("clip-path", "url(#clip)")

            // Define the div for the tooltip
            var tooltip = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Add circles and attach tooltip
            scatter
                .selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", function (d) { return x(getX(d)); })
                .attr("cy", function (d) { return y(getY(d)); })
                .attr("r", 4)
                .style("fill", "#61a3a9")
                .style("opacity", 0.5)
                .on("mouseover", function (d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(getX(d) + "<br/>" + getY(d))
                        .style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");
                })
                .on("mouseout", function (d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Set X max slider
            document.getElementById('xMaxSlider').setAttribute('min', xMin);
            document.getElementById('xMaxSlider').setAttribute('max', xMax);
            document.getElementById('xMaxSlider').setAttribute('value', xMax);
            document.getElementById('xMaxSlider').addEventListener('change', function (event) {
                x.domain([xMin, event.target.value]);
                xAxis.call(d3.axisBottom(x).ticks(5).tickSize(-height));
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return x(getX(d)) })
                    .attr('cy', function (d) { return y(getY(d)) });
                updateSliderTexts();
            });

            // Set Y max slider
            document.getElementById('yMaxSlider').setAttribute('min', yMin);
            document.getElementById('yMaxSlider').setAttribute('max', yMax);
            document.getElementById('yMaxSlider').setAttribute('value', yMax);
            document.getElementById('yMaxSlider').addEventListener('change', function (event) {
                y.domain([yMin, event.target.value]);
                yAxis.call(d3.axisLeft(y).ticks(5).tickSize(-width));
                scatter
                    .selectAll("circle")
                    .attr('cx', function (d) { return x(getX(d)) })
                    .attr('cy', function (d) { return y(getY(d)) });
                updateSliderTexts();
            });

            // Init slider texts
            updateSliderTexts();

            function updateSliderTexts() {
                document.getElementById('xMin').textContent = thousandCommas(xMin);
                document.getElementById('xMax').textContent = thousandCommas(document.getElementById('xMaxSlider').value);
                document.getElementById('yMin').textContent = thousandCommas(yMin);
                document.getElementById('yMax').textContent = thousandCommas(document.getElementById('yMaxSlider').value);
            }

            function thousandCommas(numberString) {
                if (typeof numberString === 'number') {
                    return (numberString).toLocaleString('en');
                }
                if (typeof numberString === 'string') {
                    return parseFloat(numberString).toLocaleString('en');
                }
                return numberString;
            }

            // // Set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom
            // var zoom = d3.zoom()
            //     .scaleExtent([.5, 20])  // This control how much you can unzoom (x0.5) and zoom (x20)
            //     .extent([[0, 0], [width, height]])
            //     .on("zoom", updateChart);

            // // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
            // SVG.append("rect")
            //     .attr("width", width)
            //     .attr("height", height)
            //     .style("fill", "none")
            //     .style("pointer-events", "all")
            //     .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            //     .call(zoom);
            // // now the user can zoom and it will trigger the function called updateChart

            // // A function that updates the chart when the user zoom and thus new boundaries are available
            // function updateChart() {

            //     // recover the new scale
            //     var newX = d3.event.transform.rescaleX(x);
            //     var newY = d3.event.transform.rescaleY(y);

            //     // update axes with these new boundaries
            //     xAxis.call(d3.axisBottom(newX).ticks(5).tickSize(-height))
            //     yAxis.call(d3.axisLeft(newY).ticks(5).tickSize(-width))

            //     // update circle position
            //     scatter
            //         .selectAll("circle")
            //         .attr('cx', function (d) { return newX(getX(d)) })
            //         .attr('cy', function (d) { return newY(getY(d)) });
            // }

            // reset button listener
            // document.getElementById('reset-btn').addEventListener('click', function () {
            //     zoom.transform(SVG, d3.zoomIdentity);

            //     // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
            //     SVG.append("rect")
            //         .attr("width", width)
            //         .attr("height", height)
            //         .style("fill", "none")
            //         .style("pointer-events", "all")
            //         .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            //         .call(zoom);
            // })
        })

    </script>
</body>

</html>