<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        rect {
            fill: white;
        }

        .grid path,
        .grid line {
            stroke: lightgrey;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        .grid line {
            stroke-opacity: 0.7;
        }
    </style>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
</head>

<body>

    <div id="ftrent"></div>
    <button class="btn btn-secondary" id="reset-btn">reset</button>
    <div id="selected-flats"></div>

    <script src="https://d3js.org/d3.v4.js"></script>
    <script>
        d3.csv('/24_tokwawan_cleaned.csv', function (data) {
            new ScatterPlot({
                selector: '#ftrent',
                data: data.map(d => ({ ...d, id: d.detail_url.replace('https://www.28hse.com/rent/residential/property-', 'id') })),
                width: 980,
                height: 600,
                getX: (d) => parseInt(d.saleable_area),
                getY: (d) => parseInt(d.rent),
                resetBtnSelector: '#reset-btn',
            });
        })

        class ScatterPlot {
            constructor({
                selector,
                width: overallWidth,
                height: overallHeight,
                data,
                getX = (d) => d[0],
                getY = (d) => d[1],
                resetBtnSelector,
                pointRadius = 4,
            }) {
                this.getX = getX;
                this.getY = getY;
                this.data = data;
                this.pointRadius = pointRadius;
                this.selector = selector;
                this.selectedPoints = {};

                const margin = { top: 10, right: 30, bottom: 30, left: 60 };
                this.width = overallWidth -= (margin.left + margin.right);
                this.height = overallHeight -= (margin.top + margin.bottom);

                const svg = d3.select(this.selector)
                    .on("touchstart", function noZoom() {
                        d3.event.preventDefault();
                    })
                    .on("touchmove", function noZoom() {
                        d3.event.preventDefault();
                    })
                    .append("svg")
                    .attr("width", this.width + margin.left + margin.right)
                    .attr("height", this.height + margin.top + margin.bottom);

                this.g = svg.append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")");

                this.g.append("rect")
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .on("click", function onBackgroundClicked(d, i) {
                        if (d3.event.defaultPrevented) return; // zoomed
                        // TODO: any action here
                    });

                this.createAxis();

                this.createScatter();

                const zoom = d3.zoom().on("zoom", this.zoomed);

                this.g.call(zoom);

                if (resetBtnSelector) {
                    d3.select(resetBtnSelector).on('click', () => {
                        zoom.transform(this.g, d3.zoomIdentity);
                    });
                }
            }

            zoomed = () => {
                const transform = d3.event.transform;

                this.x = transform.rescaleX(this.originalX);
                this.y = transform.rescaleY(this.originalY);

                this.xAxis.call(d3.axisBottom(this.x).ticks(5).tickSize(-this.height));
                this.yAxis.call(d3.axisLeft(this.y).ticks(5).tickSize(-this.width));

                this.scatter
                    .selectAll("circle")
                    .attr('cx', (d) => this.x(this.getX(d)))
                    .attr('cy', (d) => this.y(this.getY(d)));
            }

            createAxis = () => {
                this.originalX = d3.scaleLinear()
                    .domain([0, d3.max(this.data, this.getX) * 1.1])
                    .range([0, this.width]);
                this.x = this.originalX;
                this.xAxis = this.g.append("g")
                    .attr("class", "grid")
                    .attr("transform", "translate(0," + this.height + ")")
                    .call(d3.axisBottom(this.x).ticks(5).tickSize(-this.height));

                this.originalY = d3.scaleLinear()
                    .domain([0, d3.max(this.data, this.getY) * 1.1])
                    .range([this.height, 0]);
                this.y = this.originalY;
                this.yAxis = this.g.append("g")
                    .attr("class", "grid")
                    .call(d3.axisLeft(this.y).ticks(5).tickSize(-this.width));
            }

            createTooltip = () => {
                const g = this.g.append('g')
                    .attr('class', 'ftrent-tooltip');

                const div = g.append('foreignObject')
                    .attr('width', '100%')
                    .attr('height', '100%');

                return { g, div }
            }

            relocateTooltip = (x, y, tooltip) => {
                tooltip
                    .g
                    .attr('transform', `translate(${x}, ${y})`);
            }

            writeTooltip = (htmlString, tooltip) => {
                tooltip.div.html(htmlString);
            }

            removeTooltip = (tooltip) => {
                tooltip.g.remove();
            }

            createScatter = () => {
                const self = this;

                self.g.append("defs").append("SVG:clipPath")
                    .attr("id", "clip")
                    .append("SVG:rect")
                    .attr("width", self.width)
                    .attr("height", self.height)
                    .attr("x", 0)
                    .attr("y", 0);

                self.scatter = self.g.append("g")
                    .attr("clip-path", "url(#clip)")
                    .attr("class", "scatter");

                self.scatter.selectAll("circle")
                    .data(self.data)
                    .enter().append("circle")
                    .attr("cx", (d) => self.x(self.getX(d)))
                    .attr("cy", (d) => self.y(self.getY(d)))
                    .attr("r", this.pointRadius)
                    .style("fill", "#61a3a9")
                    .style("opacity", 0.5)
                    .on("mouseover", function (d) {
                        d3.select(this).style('fill', 'red');

                        self.oneTimeTooltip = self.createTooltip();
                        self.relocateTooltip(
                            self.x(self.getX(d) + self.pointRadius),
                            self.y(self.getY(d) - self.pointRadius),
                            self.oneTimeTooltip,
                        );
                        self.writeTooltip(
                            `
                            ${d.building_name} <br/>
                            $${self.getY(d).toLocaleString('en')}<br/>
                            ${self.getX(d).toLocaleString('en')}呎`,
                            self.oneTimeTooltip,
                        );
                    })
                    .on("mouseout", function (d) {
                        self.removeTooltip(self.oneTimeTooltip);
                        if (self.isFlatSelected(d.id)) {
                            return;
                        }
                        d3.select(this).style('fill', '#61a3a9');
                    })
                    .on('click', function (d) {
                        const { id } = d;
                        if (self.isFlatSelected(id)) {
                            d3.select(this).style('fill', '#61a3a9');
                            self.deselectFlat(d);
                        } else {
                            d3.select(this).style('fill', 'red');
                            self.selectFlat(d);
                        }
                    });
            }

            selectFlat = (data) => {
                this.selectedPoints[data.id] = data;
                const card = document.createElement('div');
                card.innerHTML = `
                    <div class="card" id="${data.id}" style="width: 18rem;">
                        <img src="..." class="card-img-top" alt="...">
                        <div class="card-body">
                            <h5 class="card-title">${data.building_name}</h5>
                            <p class="card-text">
                                租$${this.getY(data)} <br/>
                                ${this.getX(data)} 平方呎
                            </p>
                            <a href="${data.detail_url}" target="_blank" class="btn btn-secondary">Check details</a>
                        </div>
                    </div>
                `
                document.getElementById('selected-flats').appendChild(card);
            }

            deselectFlat = (data) => {
                delete this.selectedPoints[data.id];
                document.querySelector(`.card#${data.id}`).remove();
            }

            isFlatSelected = (id) => {
                return !!this.selectedPoints[id];
            }
        }
    </script>
</body>

</html>