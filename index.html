<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            background-color: #272727 !important;
        }

        rect {
            fill: #272727;
        }

        text {
            fill: #fff;
        }

        .grid {
            font-size: 16px;
        }

        .grid path,
        .grid line {
            stroke: lightgrey;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        .grid line {
            stroke-opacity: 0.7;
        }

        .scatter circle:hover {
            cursor: pointer;
        }

        .ftrent.btn-close {
            position: absolute;
            top: 0;
            right: 0;
        }
    </style>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"
        integrity="sha512-UNM1njAgOFUa74Z0bADwAq8gbTcqZC8Ej4xPSzpnh0l6KMevwvkBvbldF9uR++qKeJ+MOZHRjV1HZjoRvjDfNQ=="
        crossorigin="anonymous"></script>
</head>

<body>

    <button class="btn btn-outline-warning" id="reset-btn">reset</button>

    <script src="https://d3js.org/d3.v4.js"></script>
    <script>
        d3.csv('/24_tokwawan_cleaned.csv', function (data) {
            const getSaleableArea = (d) => parseInt(d.saleable_area)
            const getRent = (d) => parseInt(d.rent);
            new ScatterPlot({
                selector: 'body',
                data: data.map(d => ({ ...d, id: d.detail_url.replace('https://www.28hse.com/rent/residential/property-', 'id') })),
                width: innerWidth,
                height: innerHeight - 60,
                getX: getSaleableArea,
                getY: getRent,
                xLabel: '平方呎',
                yLabel: '月租',
                yTickFormat: '$,',
                resetBtnSelector: '#reset-btn',
                pointRadius: (d) => 16 * getSaleableArea(d) / d3.max(data, getSaleableArea),
                tooltipHtml: (d) => {
                    const saleableArea = getSaleableArea(d);
                    const rent = getRent(d);
                    const rentPerSq = (rent / saleableArea).toFixed(0);
                    const { detail_url, thumbnailurl: thumbnail_url, building_name } = d;

                    return `
                        <div class="card" style="width: 18rem;">
                            <img src="${thumbnail_url}" class="card-img-top" style="max-height: 180px; width: auto;" alt="thumbnail_${building_name}">
                            <div class="card-body">
                                <h5 class="card-title">${building_name}</h5>
                                <h6 class="card-subtitle mb-2 text-muted">$${rentPerSq}@呎</h6>
                                <p class="card-text">
                                    ${saleableArea.toLocaleString('en')}呎, 月租$${rent.toLocaleString('en')}
                                </p>
                                <a href="#" class="card-link">Card link</a>
                                <a href="#" class="card-link">Another link</a>
                            </div>
                        </div>
                    `;
                },
                regressionLegend: (slope, intercept) => {
                    return `土瓜灣平均呎價: $${d3.median(data, d => getRent(d) / getSaleableArea(d)).toFixed(1)}`;
                }
            });
        })

        class ScatterPlot {
            constructor({
                selector,
                width: overallWidth,
                height: overallHeight,
                data,
                getX = (d) => d[0],
                getY = (d) => d[1],
                resetBtnSelector,
                pointRadius,
                tooltipHtml,
                regressionLegend,
                xLabel = '',
                yLabel = '',
                xTickFormat = ',',
                yTickFormat = ',',
            }) {
                this.getX = getX;
                this.getY = getY;
                this.data = data;
                this.selector = selector;
                this.xLabel = xLabel;
                this.yLabel = yLabel;
                this.xTickFormat = xTickFormat;
                this.yTickFormat = yTickFormat;
                this.selectedPoints = {};
                this.pointRadius = pointRadius || function (d) {
                    return 4;
                };
                this.tooltipHtml = tooltipHtml || function (d) {
                    return `${this.getX(d)}, ${this.getY(d)}`;
                };
                this.regressionLegend = regressionLegend || function () {
                    return `y = ${this.slope.toFixed(2)}x + ${this.intercept.toFixed(2)}`
                }

                this.margin = { top: 10, right: 30, bottom: 60, left: 120 };
                this.width = overallWidth -= (this.margin.left + this.margin.right);
                this.height = overallHeight -= (this.margin.top + this.margin.bottom);

                const svg = d3.select(this.selector)
                    .on("touchstart", function noZoom() {
                        d3.event.preventDefault();
                    })
                    .on("touchmove", function noZoom() {
                        d3.event.preventDefault();
                    })
                    .append("svg")
                    .attr("width", this.width + this.margin.left + this.margin.right)
                    .attr("height", this.height + this.margin.top + this.margin.bottom);

                this.g = svg.append("g")
                    .attr("transform",
                        "translate(" + this.margin.left + "," + this.margin.top + ")");

                this.g.append("rect")
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .on("click", function onBackgroundClicked(d, i) {
                        if (d3.event.defaultPrevented) return; // zoomed
                        // TODO: any action here
                    });

                this.drawAxis();

                this.addAxisLabels();

                this.drawScatter();

                this.drawRegressionLine();

                const zoom = d3.zoom().on("zoom", this.zoomed);

                this.g.call(zoom);

                if (resetBtnSelector) {
                    d3.select(resetBtnSelector).on('click', () => {
                        zoom.transform(this.g, d3.zoomIdentity);
                    });
                }
            }

            zoomed = () => {
                const transform = d3.event.transform;

                this.x = transform.rescaleX(this.originalX);
                this.y = transform.rescaleY(this.originalY);

                this.drawAxis();

                this.drawScatter();

                this.drawRegressionLine();
            }

            drawAxis = () => {
                if (!this.originalX) {
                    this.originalX = d3.scaleLinear()
                        .domain([0, d3.max(this.data, this.getX) * 1.1])
                        .range([0, this.width]);
                }
                if (!this.x) {
                    this.x = this.originalX;
                }
                if (!this.xAxis) {
                    this.xAxis = this.g.append("g")
                        .attr("class", "grid")
                        .attr("transform", "translate(0," + this.height + ")")
                }
                this.xAxis.call(d3.axisBottom(this.x)
                    .ticks(5)
                    .tickFormat(d3.format(this.xTickFormat))
                    .tickSize(-this.height)
                );

                if (!this.originalY) {
                    this.originalY = d3.scaleLinear()
                        .domain([0, d3.max(this.data, this.getY) * 1.1])
                        .range([this.height, 0]);
                }
                if (!this.y) {
                    this.y = this.originalY;
                }
                if (!this.yAxis) {

                    this.yAxis = this.g.append("g")
                        .attr("class", "grid")
                }
                this.yAxis.call(d3.axisLeft(this.y)
                    .ticks(5)
                    .tickFormat(d3.format(this.yTickFormat))
                    .tickSize(-this.width)
                );
            }

            addAxisLabels = () => {
                this.g.append("text")
                    .attr("transform",
                        "translate(" + (this.width / 2) + " ," +
                        (this.height + this.margin.top + this.margin.bottom / 2) + ")")
                    .style("text-anchor", "middle")
                    .text(this.xLabel);

                this.g.append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 0 - this.margin.left * 0.8)
                    .attr("x", 0 - (this.height / 2))
                    .attr("dy", "1em")
                    .style("text-anchor", "middle")
                    .text(this.yLabel);
            }

            drawScatter = () => {
                const self = this;

                self.g.append("defs").append("SVG:clipPath")
                    .attr("id", "clip")
                    .append("SVG:rect")
                    .attr("width", self.width)
                    .attr("height", self.height)
                    .attr("x", 0)
                    .attr("y", 0);

                if (!self.scatter) {
                    self.scatter = self.g.append("g")
                        .attr("clip-path", "url(#clip)")
                        .attr("class", "scatter");

                    self.scatter
                        .selectAll("circle")
                        .data(self.data)
                        .enter()
                        .append("circle")
                        .attr("r", (d) => self.pointRadius(d))
                        .style("fill", "#61a3a9")
                        .style("opacity", 0.5)
                        .on("mouseover", function (d) {
                            d3.select(this).style('fill', 'red');
                            self.oneTimeTooltip = new ScatterTooltip(self.g);
                            positionTooltip(self.oneTimeTooltip, d);
                            self.oneTimeTooltip.write(self.tooltipHtml(d));
                        })
                        .on("mouseout", function (d) {
                            d3.select(this).style('fill', '#61a3a9');
                            self.oneTimeTooltip.remove();
                        })
                        .on('click', (d) => {
                            const { id } = d
                            if (self.selectedPoints[id]) {
                                return;
                            }
                            const tooltip = new ScatterTooltip(self.g);
                            positionTooltip(tooltip, d);
                            tooltip.write(self.tooltipHtml(d));
                            self.selectedPoints[id] = {
                                data: d,
                                tooltip,
                            }
                        });
                }

                self.scatter
                    .selectAll("circle")
                    .attr('cx', (d) => self.x(self.getX(d)))
                    .attr('cy', (d) => self.y(self.getY(d)));

                Object.keys(self.selectedPoints).forEach((id) => {
                    const { tooltip, data } = self.selectedPoints[id];
                    positionTooltip(tooltip, data);
                });

                function positionTooltip(tooltip, data) {
                    tooltip.relocate(
                        self.x(self.getX(data)) + 10,
                        self.y(self.getY(data)) + 10,
                    );
                }
            }

            drawRegressionLine = () => {
                if (!this.regression) {
                    this.regression = this.OLS(this.data.map(this.getX), this.data.map(this.getY));
                }

                const line = d3.line()
                    .x((d) => this.x(this.getX(d)))
                    .y((d) => this.y(this.regression(this.getX(d))));

                if (!this.regressionLine) {
                    this.regressionLine = this.g
                        .append("path")
                        .attr("d", line(this.data))
                        .attr("stroke", "lightcoral")
                        .style('opacity', 0.9)
                        .attr('stroke-width', 4);

                    this.g.append("text")
                        .attr("y", this.height * 0.8)
                        .attr("x", this.width * 0.8)
                        .attr('text-anchor', 'middle')
                        .style('fill', 'lightcoral')
                        .style('font-size', 20)
                        .text(this.regressionLegend(this.slope, this.intercept));
                } else {
                    this.regressionLine.attr("d", line(this.data));
                }
            }

            OLS = (XaxisData, Yaxisdata) => {
                var ReduceAddition = function (prev, cur) { return prev + cur; };

                // finding the mean of Xaxis and Yaxis data
                var xBar = XaxisData.reduce(ReduceAddition) * 1.0 / XaxisData.length;
                var yBar = Yaxisdata.reduce(ReduceAddition) * 1.0 / Yaxisdata.length;

                var SquareXX = XaxisData.map(function (d) { return Math.pow(d - xBar, 2); })
                    .reduce(ReduceAddition);

                var ssYY = Yaxisdata.map(function (d) { return Math.pow(d - yBar, 2); })
                    .reduce(ReduceAddition);

                var MeanDiffXY = XaxisData.map(function (d, i) { return (d - xBar) * (Yaxisdata[i] - yBar); })
                    .reduce(ReduceAddition);

                this.slope = MeanDiffXY / SquareXX;
                this.intercept = yBar - (xBar * this.slope);

                // returning regression function
                return function (x) {
                    return x * this.slope + this.intercept
                }
            }
        }

        class ScatterTooltip {
            constructor(d3Selection) {
                this.g = d3Selection
                    .append('g')
                    .attr('class', 'ftrent-tooltip');
                this.foreignObject = this.g.append('foreignObject')
                    .attr('width', '18rem')
                    .attr('height', '24rem');
            }

            relocate = (x, y) => {
                this.g.attr('transform', `translate(${x}, ${y})`);
            }

            write = (htmlString) => {
                const closeBtnId = uuid.v4();
                this.foreignObject.html(
                    `
                        <div style="position: relative;">
                            ${htmlString}
                            <button id="${closeBtnId}" type="button" class="ftrent btn-close" aria-label="Close"></button>
                        </div>
                    `
                );
                document.getElementById(closeBtnId).addEventListener('click', () => {
                    this.remove();
                });
            }

            remove = () => {
                this.g.remove();
            }
        }
    </script>
</body>

</html>